# -*- coding: utf-8 -*-
"""Diseño de trenes DE.ipynb
Automatically generated by Colab.
"""

import time
import numpy as np
from collections import Counter

def train_design(x):
    target_ratio = 1 / 6.931
    ratio = (x[0, 2] * x[0, 1]) / (x[0, 0] * x[0, 3])
    return (target_ratio - ratio) ** 2

execution_times = []
dimensions = 4
lower_bound = 12
upper_bound = 60
f_range = np.tile([lower_bound, upper_bound], (dimensions, 1))
max_iter = 1000
num_agents = 20
runs = 30

best_solutions = []
best_errors = []

target_ratio = 1 / 6.931

for _ in range(runs):
    start_time = time.time()
    agents = np.random.randint(lower_bound, upper_bound + 1, (num_agents, dimensions))
    fitness = np.array([train_design(np.array([a])) for a in agents])
    best_idx = np.argmin(fitness)
    best_position = agents[best_idx]
    best_fitness = fitness[best_idx]

    aux_selector = np.arange(num_agents)
    m = 0.5
    cross_p = 0.2
    iter = 1

    while iter < max_iter:
        for i in range(num_agents):
            indexes = aux_selector[aux_selector != i]
            r1, r2, r3 = agents[np.random.choice(indexes, 3, replace=False)]
            mutant = r1 + m * (r2 - r3)
            trial = np.where(np.random.rand(dimensions) <= cross_p, mutant, agents[i])
            trial = np.clip(np.round(trial), lower_bound, upper_bound).astype(int)

            fitness_trial = train_design(np.array([trial]))
            if fitness_trial < fitness[i]:
                agents[i] = trial
                fitness[i] = fitness_trial
                if fitness_trial < best_fitness:
                    best_position = trial
                    best_fitness = fitness_trial
        iter += 1

    best_solutions.append(best_position)
    best_errors.append(best_fitness)
    end_time = time.time()
    execution_times.append(end_time - start_time)

avg_time = np.mean(execution_times)
print(f"\nTiempo promedio por ejecución: {avg_time:.2f} segundos")
solutions_array = np.array(best_solutions)
avg_solution = np.mean(solutions_array, axis=0)
avg_error = np.mean(best_errors)
std_error = np.std(best_errors)

sol_tuples = [tuple(sol) for sol in best_solutions]
counter = Counter(sol_tuples)
common_solution, count = counter.most_common(1)[0]
common_error = train_design(np.array([common_solution]))

modes = [Counter(solutions_array[:, i]).most_common(1)[0][0] for i in range(dimensions)]
mode_error = train_design(np.array([modes]))

sorted_indices = np.argsort(best_errors)
top_solutions = [best_solutions[i] for i in sorted_indices[:3]]
top_errors = [best_errors[i] for i in sorted_indices[:3]]
top_ratios = [(s[2] * s[1]) / (s[0] * s[3]) for s in top_solutions]

print("Análisis")
print(f"Promedio de posibles soluciones {np.round(avg_solution, 2).tolist()}")
print(f"Error del promedio: {avg_error:.2e}")
print(f"Solucion más recurrente {common_solution}")
print(f"Veces que aparece la solución mas recurrente {count}")
print(f"Error de la recurrente {common_error:.2e}")
print("3 Mejores soluciones")
for i in range(3):
    sol = top_solutions[i]
    err = top_errors[i]
    ratio = top_ratios[i]
    print(f"{i+1}. [A:{sol[0]} B:{sol[1]} D:{sol[2]} F:{sol[3]}]")
    print(f"   Error: {err:.2e} | Relación: {ratio:.6f} (Objetivo: {target_ratio:.6f})")